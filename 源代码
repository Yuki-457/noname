let bgImage, blockImage, blockImage2, spikeImage, playerImage, groundImage, portalImgClosed, portalImgOpened, playerImg1, playerImg2, pipeImg, monsterImg1, bulletImg, turretImg, coinImg, coverImg, logo2Img;

let buttons = [];
let gameState = "menu";
let volume = 5;
let controls = {left:'A', right:'D', attack:'J', jump:'K', item:'I', pause:'P', use:'E'};
let controlKeys = Object.keys(controls);
let changingKey = null;
let titleFontSize = 48;
let titleY;
let groundHeight = 150;
let sceneIndex = 0;
let goldCoins = 0;
let level = 1;
let exp = 0;
let elapsedTime = 0;
//let portals = [];
let unlockedPortals = [];
let isChoosingPortal = false;
let selectedPortalIndex = 0;
//let spikes = [];
let currentSpawnPoint = null;
//let platforms = [];
//let coins = [];
//let enemies = [];
let scenes = [];
let maxScenes = 3;
let hiddenScenes = [];
let hiddenSceneIndex = 0;
let inHiddenScene = false;
let hiddenMaxScenes = 3;
let difficultyButtons = []; 
let difficulty = "easy"; 
let backButton;
let upgradeButtons = [];

function setup() {
  createCanvas(800, 600);
  textAlign(CENTER, CENTER);
  titleY = height / 4;//设置标题位置
  sceneIndex = 0;
  
  let startY = height / 2;
  
  buttons.push(new Button(width / 2 - 100, height / 2 - 10, "New Start", () => gameState = "difficultySelect"));
  buttons.push(new Button(width / 2 - 100, height / 2 + 50, "Continue", () => console.log("Load Game")));
  buttons.push(new Button(width / 2 - 100, height / 2 + 110, "Setting", () => gameState = "settings"));
  buttons.push(new Button(width / 2 - 100, height / 2 + 170, "Exit", () => noLoop()));
  //按钮位置
  
  // 創建難度選擇按鈕
  difficultyButtons.push(new Button(width / 2 - 100, height / 2 - 40, "Easy Mode", () => {
    difficulty = "easy";
    gameState = "playing"; // 進入遊戲
  }));

  difficultyButtons.push(new Button(width / 2 - 100, height / 2 + 40, "Hard Mode", () => {
    difficulty = "hard";
    gameState = "playing"; // 進入遊戲
  }));

  backButton = new Button(width / 2 - 100, height - 150, "Back", () => {
    if (gameState === "difficultySelect") {
      gameState = "menu";
    }
  });
  
  player = new Player(50, height - groundHeight - 40);
  //portals.push(new Portal(100, height - groundHeight - 60));
  //currentSpawnPoint = {x: 100, y: height - groundHeight - 50};
  //spikes.push(new Spike(250, height - groundHeight, 50));
  
  for(let i = 0; i <= maxScenes; i++){
    scenes.push(new Scene());
  }
  
  scenes[0].addPlatform(450, height - groundHeight - 130, 30, true);
  scenes[0].addPlatform(480, height - groundHeight - 130, 30, true);
  scenes[0].addPlatform(510, height - groundHeight - 130, 30, true);
  scenes[0].addPlatform(540, height - groundHeight - 130, 30, true);
  scenes[0].addEnemy(400, height - groundHeight - 25, 25, 25, 2, 400, 700);
  scenes[0].addSpike(250, height - groundHeight, 50);
  //scenes[0].addCoin(460, height - groundHeight - 160);
  
  let portal1 = scenes[0].addPortal(100, height - groundHeight - 60, "main", 0);
  lastCheckPoint = { x: portal1.x, y: portal1.y, scene: 0 };
  
  scenes[1].addCliff(150, 200);
  scenes[1].addCliff(250, 300);
  
  scenes[1].addTurret(165, height - 20);
  scenes[1].addTurret(265, height - 20);
  
  for(let x = 150; x <= 270; x += 30){
    scenes[1].addPlatform(x, height - groundHeight - 240, 30, false);
  }
  
  for(let x = 150; x <= 270; x += 30){
    scenes[1].addCoin(x + 15, height - groundHeight - 260, false);
  }
  //方块阵列
  //上下兩側方塊條
  for(let i = 0; i < 4; i++){
    
    let xPos = 450 + i * 30; // 計算 X 座標

    if (i === 1 || i === 2) { 
        scenes[1].addBreakableBlock(xPos, height - groundHeight - 100, 30);
    } else {
        scenes[1].addPlatform(xPos, height - groundHeight - 100, 30, false);
    }
    scenes[1].addPlatform(450 + i * 30, height - groundHeight - 220, 30, false);
  }
  
  //左右兩側方塊條
  
  for(let i = 0; i < 5; i++){
    scenes[1].addPlatform(450, height - groundHeight -(100 + i * 30), 30, false);
    scenes[1].addPlatform(540, height - groundHeight -(100 + i * 30), 30, false);
  }
  
  for(let i = 1; i < 3; i++){
    for(let j = 0; j < 3; j++){
      scenes[1].addCoin(450 + i * 30 + 15, height - groundHeight -(100 + j * 30 + 15), false);
    }
  }
  
  /*for(let i = 0; i < 4; i++){
    scenes[1].addBreakableBlock(450 + i * 30, 130, 30);
  }*/
  
  scenes[1].addPipe(650, height - groundHeight - 110, 75, 110);
  
  hiddenScenes = [];
  for(let i = 0; i < hiddenMaxScenes; i++){
    hiddenScenes.push(new Scene());
  }
  
  hiddenScenes[0].addCliff(200, 800);
  hiddenScenes[1].addCliff(0,800);
  hiddenScenes[2].addCliff(0,500);
  
  let hiddenPortal = hiddenScenes[0].addPortal(100, height - groundHeight - 60, "hidden", 0);
 // hiddenPortal.unlocked = true;
  //unlockedPortals.push(hiddenPortal);
  
  hiddenScenes[0].addGate(200);
  hiddenScenes[0].addSwitch(70, height - groundHeight - 20);
  hiddenScenes[0].addChasingSpike();
  
  hiddenScenes[0].addPlatform(330, height - groundHeight - 10, 30, true);
  hiddenScenes[0].addPlatform(410, height - groundHeight - 10, 30, true);
  hiddenScenes[0].addPlatform(440, height - groundHeight - 10, 30, true);
  hiddenScenes[0].addPlatform(530, height - groundHeight - 10, 30, true);
  hiddenScenes[0].addPlatform(560, height - groundHeight - 10, 30, true);
  hiddenScenes[0].addPlatform(680, height - groundHeight - 100, 30, true);
  hiddenScenes[0].addPlatform(710, height - groundHeight - 100, 30, true);
  hiddenScenes[0].addPlatform(740, height - groundHeight - 100, 30, true);
  hiddenScenes[0].addPlatform(770, height - groundHeight - 100, 30, true);
  hiddenScenes[0].addPlatform(810, height - groundHeight - 100, 30, true);
  
  hiddenScenes[1].addPlatform(0, height - groundHeight - 10, 30, true);
  hiddenScenes[1].addPlatform(30, height - groundHeight - 10, 30, true);
  hiddenScenes[1].addPlatform(150, height - groundHeight - 100, 30, true);
  hiddenScenes[1].addPlatform(250, height - groundHeight - 100, 30, true);
  hiddenScenes[1].addPlatform(350, height - groundHeight - 180, 30, true);
  hiddenScenes[1].addPlatform(350, height - groundHeight - 10, 30, true);
  hiddenScenes[1].addMovablePlatform(450, height - groundHeight - 300, 450, height - groundHeight - 330, 30, 5);
  hiddenScenes[1].addPlatform(450, height - groundHeight - 100, 30, true);
  hiddenScenes[1].addMovablePlatform(510, height - groundHeight - 10, 480, height - groundHeight - 10, 30, 5);
  hiddenScenes[1].addPlatform(610, height - groundHeight - 100, 30, true);
  hiddenScenes[1].addPlatform(640, height - groundHeight - 100, 30, true);
  hiddenScenes[1].addPlatform(750, height - groundHeight - 100, 30, true);
  //hiddenScenes[1].addPlatform(800, height - groundHeight - 100, 30, true);
  
  //hiddenScenes[2].addPlatform(0, height - groundHeight - 100, 30, true);
  hiddenScenes[2].addPlatform(30, height - groundHeight - 70, 30, true);
  hiddenScenes[2].addPlatform(60, height - groundHeight - 70, 30, true);
  
  for(let i = 0; i < 4; i++){
    hiddenScenes[2].addPlatform(30, height - groundHeight -(200 + i * 30), 30, false);
    hiddenScenes[2].addPlatform(60, height - groundHeight -(200 + i * 30), 30, false);
  }
    hiddenScenes[2].addPlatform(130, height - groundHeight - 150, 30, true);
    hiddenScenes[2].addPlatform(160, height - groundHeight - 150, 30, true);
    hiddenScenes[2].addPlatform(240, height - groundHeight - 100, 30, true);
    hiddenScenes[2].addPlatform(270, height - groundHeight - 100, 30, true);
    hiddenScenes[2].addPlatform(380, height - groundHeight - 100, 30, true);
    hiddenScenes[2].addPlatform(410, height - groundHeight - 100, 30, true);
    hiddenScenes[2].addPlatform(440, height - groundHeight - 100, 30, true);
}

function draw() {
  background(240);
  
  if(gameState === "menu"){
    drawMenu();
  }
  else if(gameState === "difficultySelect"){
    drawDifficultyMenu();
  }
  else if(gameState === "settings"){
    drawSettings();
  }
  else if(gameState === "playing"){
    drawGame();
  }
  else if(gameState === "upgrade"){
    drawUpgrade();
  }
}

function drawMenu(){
  image(coverImg, 0, 0, 800, 600);      
  textSize(titleFontSize);
  
  // 計算 logo 要多大
  let logoW = 430;  // 你想要的寬度
  let logoH = logo2Img.height * (logoW / logo2Img.width);  // 維持比例的高度
  
  // 把 logo 畫在中間
  image(logo2Img, (width - logoW) / 2-10, 50, logoW, logoH);  
  
  for (let btn of buttons) {
    btn.display();
  }
}

function drawDifficultyMenu() {
  image(coverImg, 0, 0, 800, 600); 
  
  // 加半透明黑色遮罩
  fill(0, 150);   // 0是黑色，150是透明度 (0~255)
  rect(0, 0, width, height);
  
  fill(255);  
  textSize(50);
  text("Select Difficulty", width / 2, height / 3);
  
  // 顯示按鈕
  for (let btn of difficultyButtons) {
    btn.display();
  }
  
  console.log("Current gameState:", gameState);
  backButton.display();  // 顯示返回按鈕

}

function drawGame(){
  image(bgImage, 0, 0, width, height);
  
  
  noStroke();
  image(groundImage, 0, height - groundHeight, width, groundHeight)
  
  rect(0, height - groundHeight, width, groundHeight);
  fill(90, 194, 108);
  let currentScene = inHiddenScene ? hiddenScenes[hiddenSceneIndex] : scenes[sceneIndex];
  for (let cliff of currentScene.cliffs) {
    rect(cliff.startX, height - groundHeight, cliff.endX - cliff.startX, groundHeight);
  }
  
  
  //for(let portal of portals){
    //portal.update();
   // portal.display();
  //}
  
  
  
  /*for(let spike of spikes){
    spike.update();
    spike.display();
  }
  
  
  for(let platform of platforms){
    platform.update();
    platform.display();
  }
  
  for(let coin of coins){
    coin.update();
    coin.display();
  }
  
  for(let enemy of enemies){
    enemy.update();
    enemy.display();
  }
  
  */
  for (let s of scenes) {
    s.update(); 
  }
  
  for (let s of hiddenScenes) {
    s.update(); 
  }
  for (let s of hiddenScenes[0].chasingSpikes) {
    s.update(); // 总是更新追踪刺
  }
  for (let s of hiddenScenes[0].chasingSpikes) {
    s.display(); // 只绘制当前所在幕
  }

  currentScene.display();
  
  player.update();
  player.display();
  drawHUD();
  
  //fill(0);
  //textSize(20);
  //text(`Scene: ${sceneIndex}`, width - 80, 30);
  
  if(isChoosingPortal){
    drawPortalSelection();
  }
}

class Platform{
  constructor(x, y, size, hasCoin = true, scene){
    this.x = x;
    this.y = y + 14;
    this.size = size;
    this.hasCoin = hasCoin;
    this.scene = scene;
  }
  
  update(){
    if (!isInCurrentScene(this.scene)) return;
/*    if(player.x + player.w > this.x && player.x < this.x + this.size &&
       //player.y == this.y + this.size && player.velocityY < 0){
       //player.y - player.velocityY < this.y + this.size && player.y + player.velocityY < this.y + this.size){
       player.y <= this.y + this.size && player.y >= this.y && player.velocityY < 0){
      player.velocityY = 0;
      if(this.hasCoin){
        let newCoin = new Coin(this.x + this.size / 2, this.y - 10);
        scenes[sceneIndex].coins.push(new Coin(this.x + this.size / 2, this.y - 10));
        this.hasCoin = false;
      }
    }
    
    if(player.x + player.w > this.x && player.x < this.x + this.size &&
       player.y + player.h >= this.y && player.y + player.h - player.velocityY < this.y + 5 &&
       player.velocityY > 0){
      player.y = this.y - player.h;
      player.velocityY = 0;
      player.onGround = true;
    }
    
//    if(player.x + player.w > this.x && player.x < this.x + this.size &&
 //      player.y + player.h > this.y && player.velocityY > 0){
   //   player.y = this.y - player.h;
     // player.velocityY = 0;
     // player.onGround = true;
    //}
*/    
    let currentScene = inHiddenScene ? hiddenScenes[hiddenSceneIndex] : scenes[sceneIndex];
    let hasBlockAbove = currentScene.platforms.some(platform =>
      platform.x === this.x && platform.y === this.y - this.size
    );
    
    if (player.y + player.h > this.y && player.y < this.y + this.size) {
      // **人物从右侧撞到方块**
      let nextX = player.x + player.velocityX; // 预测下一帧 X 位置
      if (player.velocityX > 0 && player.prevX + player.w <= this.x + 1 && nextX + player.w > this.x) {
        if (!currentScene.platforms.some(p => p !== this && p.x === this.x - this.size && p.y === this.y)) {
          player.x = this.x - player.w;
          player.velocityX = 0;
        }
      }
      // **人物从左侧撞到方块**
      if (player.velocityX < 0 && player.prevX >= this.x + this.size - 1 && nextX < this.x + this.size) {
        if (!currentScene.platforms.some(p => p !== this && p.x === this.x + this.size && p.y === this.y)) {
          player.x = this.x + this.size;
          player.velocityX = 0;
        }
      }
    }
    
    if (player.x + player.w > this.x && player.x < this.x + this.size &&
        player.y < this.y + this.size && player.prevY >= this.y + this.size &&
        player.velocityY < 0) {
      player.y = this.y + this.size;
      player.velocityY = 0;
      
      if (this.hasCoin) {
        currentScene.coins.push(new Coin(this.x + this.size / 2, this.y - 10));
        this.hasCoin = false;
      }
      return; 
    }
    
    if (!hasBlockAbove && player.x + player.w > this.x && player.x < this.x + this.size &&
        player.y + player.h > this.y && player.prevY + player.h <= this.y &&
        player.velocityY > 0) {
      player.y = this.y - player.h;
      player.velocityY = 0;
      player.onGround = true;
      return;
    }
    
    
  }
  
  display(){
    if (!isInCurrentScene(this.scene)) return;
    image(blockImage, this.x, this.y, this.size, this.size);
  }
}

class Coin{
  constructor(x, y, hasGravity = true, scene){
    this.x = x - 7;
    this.y = y + 7;
    this.size = 15;
    this.collected = false;
    this.hasGravity = hasGravity;
    this.velocityY = hasGravity ? -2 : 0;
    this.gravity = hasGravity ? 0.5 : 0;
    this.scene = scene;
  }
  
  update(){
    if (!isInCurrentScene(this.scene)) return;
    if(this.hasGravity){
      this.velocityY += this.gravity;
      this.y += this.velocityY;
    }
    
    if(player.x + player.w > this.x && player.x < this.x + this.size &&
       player.y + player.h > this.y && player.y < this.y + this.size &&
       !this.collected){
      this.collected = true;
      collection();
      
      // let index = scenes[sceneIndex].coins.indexOf(this);
      // if(index > -1){
      //   scenes[sceneIndex].coins.splice(index, 1);
      // }
    }
  }
  
  display(){
    if (!isInCurrentScene(this.scene)) return;
    if(!this.collected){
      image(coinImg, this.x, this.y, this.size, this.size);
    }
  }
}

class Spike{
  constructor(x, y, w, scene){
    this.x = x;
    this.y = height - groundHeight + 14;
    this.w = w;
    this.h = 15;
    this.visible = false;
    this.scene = scene;
  }
  
  update(){
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    if(difficulty === "easy"){
      this.visible = true;
    }
    if(difficulty === "hard"){
      if(dist(player.x + 20, player.y + 30, this.x + this.w / 2, this.y) < 70){
        this.visible = true;
      }
    }
    
    if(this.visible && this.isCollidingWithPlayer()){
      respawnPlayer();
      if(difficulty === "hard"){
        this.visible = false;
      }
    }
  }
  
  display(){
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    if(this.visible){
      image(spikeImage, this.x, this.y - this.h, this.w, this.h);
      //triangle(this.x, this.y, this.x + this.w / 2, this.y - this.h, this.x + this.w, this.y);
    }
  }
  
  isCollidingWithPlayer(){
    return(player.x < this.x + this.w && player.x + player.w > this.x && 
           player.y + player.h > this.y - this.h);
  }
}

function respawnPlayer(){
  if(lastCheckPoint){
    if(lastCheckPoint.sceneType === "hidden"){
      inHiddenScene = true;
      hiddenSceneIndex = lastCheckPoint.scene;
    }
    else{
      inHiddenScene = false;
      sceneIndex = lastCheckPoint.scene;
    }
    player.x = lastCheckPoint.x;
    player.y = lastCheckPoint.y;
    
  }
  else{
    inHiddenScene = false;
    sceneIndex = 0;
    player.x = 50;
    player.y = height - groundHeight - 40;
  }
    
  exp = 0;
  
  for (let s of scenes) {
    for (let coin of s.coins) {
      coin.collected = false;
    }
  }
  for (let s of hiddenScenes) {
    for (let coin of s.coins) {
      coin.collected = false;
    }
  }
  //scene.coins = [];
  
  for (let s of scenes) {
    for(let spike of s.spikes){
      spike.visible = false;
    }
  }
  
  for (let s of hiddenScenes) {
    for(let spike of s.spikes){
      spike.visible = false;
    }
  }
  
  for (let s of scenes) {
    for(let platform of s.platforms){
      platform.hasCoin = true;
    }
    //scene.coins.push(new Coin(platform.x + platform.size / 2, platform.y - 10));
  }
  
  for (let s of hiddenScenes) {
    for(let platform of s.platforms){
      platform.hasCoin = true;
    }
    //scene.coins.push(new Coin(platform.x + platform.size / 2, platform.y - 10));
  }
  
  for (let s of scenes) {
    for (let movablePlatform of s.movablePlatforms) {
      movablePlatform.reset();
    }
  }
  
  for (let s of hiddenScenes) {
    for (let movablePlatform of s.movablePlatforms) {
      movablePlatform.reset();
    }
  }
  
  for (let gate of hiddenScenes[0].gates) {
    gate.reset();
  }
  
  for (let s of hiddenScenes[0].switches) {
    s.reset();
  }
  
  for (let cs of hiddenScenes[0].chasingSpikes) {
    cs.reset();
  }
  
  //scene.enemies = [];
  //scene.spikes = [];
  setupNextScene();
}

function drawPortalSelection(){
  fill(0, 150);
  rect(200, 150, 400, 300, 20);
  fill(250);
  textSize(24);
  text("Select a Portal", 400, 180);
  
  for(let i = 0; i < unlockedPortals.length; i++){
    let portal = unlockedPortals[i];
    fill(i === selectedPortalIndex ? "yellow" : "white");
    let label = portal.sceneType === "main" ? "Main" : "Hidden"
    text(`${label} Scene ${portal.sceneIndex + 1}`, 400, 220 + i * 40);
  }
  
  textSize(16);
  fill(200);
  text("↑/↓ to navigate, E to confirm, ESC to cancel", 400, 420);
}

function drawHUD(){
  fill(255);
  textSize(16);
  
  text(`Level ${level}`, 80, 30);
  fill("gold");
  rect(20, 40, (exp / 10) * 100, 10);
  noFill();
  stroke(255);
  rect(20, 40, 100, 10);
  
  let timeElapsed = Math.floor(millis() / 1000);
  text(`Time: ${timeElapsed}s`, width - 80, 30);
}

class Portal{
  constructor(x, y, sceneType, sceneIndex, scene){
    this.x = x;
    this.y = y + 14;
    this.w = 60;
    this.h = 60;
    this.unlocked = false;
    this.sceneType = sceneType;
    this.sceneIndex = sceneIndex;
    this.scene = scene;
  }
  
  update(){
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    if(!this.unlocked && this.isCollidingWithPlayer()){
      this.unlocked = true;
      if(!unlockedPortals.includes(this)){
        unlockedPortals.push(this);
      }
      
      goldCoins += 5;
      exp += 5;
      lastCheckPoint = { x: this.x, y: this.y, scene: inHiddenScene ? hiddenSceneIndex : sceneIndex, sceneType: inHiddenScene ? "hidden" : "main"};
    }
    
    if(this.unlocked && this.isCollidingWithPlayer() && keyIsDown(controls.use.charCodeAt(0))){
      isChoosingPortal = true;
      selectedPortalIndex = 0;
    }
  }
  
  display(){
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    if(this.unlocked){
      image(portalImgOpened, this.x, this.y, this.w, this.h);
    }
    else{
      image(portalImgClosed, this.x, this.y, this.w, this.h);
    }
  }
  
  isCollidingWithPlayer(){
    return(player.x < this.x + this.w && player.x + player.w > this.x &&
           player.y < this.y + this.h && player.y + player.h > this.y);
  }
}

function teleport(targetPortal){
  if(targetPortal){
    player.x = targetPortal.x;
    player.y = targetPortal.y;
    
    if(targetPortal.sceneType === "main"){
      inHiddenScene = false;
      sceneIndex = targetPortal.sceneIndex;
    }
    
    else if(targetPortal.sceneType === "hidden"){
      inHiddenScene = true;
      hiddenSceneIndex = targetPortal.sceneIndex;
    }
    
    lastCheckPoint = { x: targetPortal.x, y: targetPortal.y, scene: inHiddenScene ? hiddenSceneIndex : sceneIndex, sceneType: inHiddenScene ? "hidden" : "main"};
    
    setupNextScene();
  }
  
  isChoosingPortal = true;
}

function collection(){
  goldCoins += 1;
  exp += 1;
  if(exp >= 10){
    exp -= 10;
    level += 1;
    gameState = "upgrade";
  }
}

class Player{
  constructor(x, y){
    this.x = x;
    this.y = y + 14;
    this.w = 25;
    this.h = 40;
    this.speed = 3;
    this.gravity = 0.5;
    this.jumpPower = -Math.sqrt(2 * this.gravity * 150);
    this.velocityX = 0;
    this.velocityY = 0;
    this.onGround = false;
    this.canDoubleJump = false;
    this.hasDoubleJumped = false;
    
    this.facingRight = true;
    this.frameCounter = 0;
    this.imageIndex = 0;
  }
  
  update(){
    this.prevX = this.x;
    this.prevY = this.y;
    
    let moving = false;
    this.velocityX = 0;
    
    if(keyIsDown(controls.left.charCodeAt(0))){
      this.velocityX = -this.speed;
      this.facingRight = false;
      moving = true;
    }
    if(keyIsDown(controls.right.charCodeAt(0))){
      this.velocityX = this.speed;
      this.facingRight = true;
      moving = true;
    }
    
    if(moving){
      this.frameCounter++;
      if(this.frameCounter >= 6){
        this.imageIndex = 1 - this.imageIndex;
        this.frameCounter = 0;
      }
    }
    else{
      this.imageIndex = 0;
      this.frameCounter = 0;
    }
    
    checkFallDeath();
    
    if(!this.onGround){
      this.velocityY += this.gravity;
    }
    
    this.x += this.velocityX;
    this.y += this.velocityY;
    
    let isOnPlatform = false;
    let currentScene = inHiddenScene ? hiddenScenes[hiddenSceneIndex] : scenes[sceneIndex];

    for (let platform of currentScene.platforms) {
        if (
            this.prevX + this.w > platform.x + 1 && this.prevX < platform.x + platform.size &&
            this.y + this.h >= platform.y && this.prevY + this.h <= platform.y + 5
        ) {
            this.y = platform.y - this.h;
            this.velocityY = 0;
            isOnPlatform = true;
            break;
        }
    }
    
    let isOnPipe = false;
    for (let pipe of currentScene.pipes) {
        if (
            this.prevX + this.w > pipe.x + 1 && this.prevX < pipe.x + pipe.w &&
            this.y + this.h >= pipe.y && this.prevY + this.h <= pipe.y + 5
        ) {
            this.y = pipe.y - this.h;
            this.velocityY = 0;
            isOnPipe = true;
            break;
        }
    }
    
    let isOnMovablePlatform = false;
    for (let movablePlatform of currentScene.movablePlatforms) {
        if (
            this.prevX + this.w > movablePlatform.x + 1 && this.prevX < movablePlatform.x + movablePlatform.w &&
            this.y + this.h >= movablePlatform.y && this.prevY + this.h <= movablePlatform.y + 5
        ) {
            this.y = movablePlatform.y - this.h;
            this.velocityY = 0;
            isOnMovablePlatform = true;
            break;
        }
    }
     
    if (isOnPipe || isOnPlatform || isOnMovablePlatform) {
        this.onGround = true;
        this.hasDoubleJumped = false;
    } 
    else if (!isPlayerOverCliff() && (this.y >= height - groundHeight + 14 - this.h || isOnPlatform || isOnPipe || isOnMovablePlatform)) {
      this.y = (isOnPlatform || isOnPipe || isOnMovablePlatform) ? this.y : height - groundHeight + 14 - this.h;
      this.velocityY = 0;
      if (!this.onGround) {
        this.onGround = true;
        this.hasDoubleJumped = false;  
      }
    } 
    else {
      this.onGround = false;
    }

    this.checkSceneTransition();
    
    this.x = constrain(this.x, 0 - this.w / 2, width - this.w / 2);
  }
  
  
  
  checkSceneTransition(){
    let centerX = this.x + this.w / 2;
    if(inHiddenScene){
      if(centerX >= width && hiddenSceneIndex < hiddenMaxScenes - 1){
        hiddenSceneIndex++;
        this.x = - this.w / 2 + 1
        setupNextScene();
      }
    
      else if(centerX <= 0 && hiddenSceneIndex > 0){
        hiddenSceneIndex--;
        this.x = width - this.w / 2 - 1;
        setupNextScene();
      }
      
      else{
        if(hiddenSceneIndex === 0 && centerX <= 0){
         this.x = - this.w / 2 + 1;
        }
      
        if(hiddenSceneIndex === hiddenMaxScenes - 1 && centerX >= width){
          this.x = width - this.w / 2;
        }
      }
    }
    else{
      if(centerX >= width && sceneIndex < maxScenes - 1){
        sceneIndex++;
        this.x = - this.w / 2 + 1;
        setupNextScene();
      }
    
      if(centerX <= 0 && sceneIndex > 0){
        sceneIndex--;
        this.x = width - this.w / 2;
        setupNextScene();
      }
    }
  }
  
  display(){
    let imgToShow = this.imageIndex === 0 ? playerImg1 : playerImg2;
    
    if(!this.facingRight){
      push();
      scale(-1, 1);
      image(imgToShow, -this.x - this.w, this.y, this.w, this.h);
      pop();
    }
    else{
      image(imgToShow, this.x, this.y, this.w, this.h);
    }
  }
}

function drawSettings(){
  fill(50);
  textSize(32);
  text("Settings", width / 2, 50);
  
  textSize(24);
  text("Volume", width / 2, 150);
  text(volume, width / 2, 180);
  rect(width / 2 - 70, 170, 30, 30);
  rect(width / 2 + 40, 170, 30, 30);
  text("-", width / 2 - 55, 185);
  text("+", width / 2 + 55, 185);
  
  let controlLabels = ["Left", "Right", "Attack", "Jump", "Item", "Pause", "Use"];
  let keys = Object.values(controls);
  
  for(let i = 0; i < controlLabels.length; i++){
    let y = 250 + i * 40;
    
    let displayText = changingKey === controlKeys[i] ? "Press any key..." : `${controlLabels[i]}: ${keys[i]}`;
    
    if(changingKey === controlKeys[i]){
      fill(255, 0, 0);
    }
    else{
      fill(0);
    }
    text(displayText, width / 2, y);
    
    stroke(0);
    noFill();
    rect(width / 2 - 100, y - 15, 200, 30);
  }
  
  textSize(20);
  text("Press any key to change setting", width / 2, 520);
  text("Press ESC to return", width / 2, 550);
}

function mousePressed(){
  if(gameState === "menu"){
    for(let btn of buttons){
      btn.checkClick();
    }
  }
  else if (gameState === "difficultySelect") { 
    for (let btn of difficultyButtons) { 
      btn.checkClick(); // 確保難度選擇按鈕可以被點擊
    }
    backButton.checkClick();
  } 
  else if(gameState === "settings"){
    if(mouseX > width / 2 - 70 && mouseX < width / 2 - 40 && mouseY > 170 && mouseY < 200){
      volume = max(0, volume - 1);
    }
    if(mouseX > width / 2 + 40 && mouseX < width / 2 + 70 && mouseY > 170 && mouseY < 200){
      volume = min(10, volume + 1);
    }
    
    let controlLabels = ["Left", "Right", "Attack", "Jump", "Item", "Pause", "Use"];
    for(let i = 0; i < controlLabels.length; i++){
      let y = 250 + i * 40;
      if(mouseX > width / 2 - 100 && mouseX < width / 2 + 100 && mouseY > y - 15 && mouseY < y + 15){
        changingKey = controlKeys[i];
      }
    }
  }
  
  else if (gameState === "upgrade") {
    for(let btn of upgradeButtons){
      btn.checkClick();
    }
  }
}

function keyPressed(){
  if(gameState === "settings"){
    if(keyCode === ESCAPE){
      changingKey = null;
      gameState = "menu";
    }
    else if(changingKey){
      controls[changingKey] = key.toUpperCase();
      changingKey = null;
    }
  }
  
  else if(isChoosingPortal){
    if(keyCode === UP_ARROW){
      selectedPortalIndex = (selectedPortalIndex - 1 + unlockedPortals.length) % unlockedPortals.length;
    }
    else if(keyCode === DOWN_ARROW){
      selectedPortalIndex = (selectedPortalIndex + 1) % unlockedPortals.length;
    }
    else if(keyCode === controls.use.charCodeAt(0)){
      teleport(unlockedPortals[selectedPortalIndex]);
      isChoosingPortal = false;
    }
    else if(keyCode === ESCAPE){
      isChoosingPortal = false;
    }
  }
  
  else if (keyCode === controls.use.charCodeAt(0)) {
    let scene = inHiddenScene ? hiddenScenes[hiddenSceneIndex] : scenes[sceneIndex];
    for (let s of scene.switches) {
      s.activate(); 
    }
  }
  else if(keyCode === controls.jump.charCodeAt(0)){
      if(player.onGround){
        player.velocityY = player.jumpPower;
        player.onGround = false;
        player.hasDoubleJumped = false;
      }
      else if(player.canDoubleJump && !player.hasDoubleJumped){
        player.velocityY = player.jumpPower * 0.9;
        player.hasDoubleJumped = true;
      }
    }
}

class Button{
  constructor(x, y, label, action){
    this.x = x;
    this.y = y;
    this.label = label;
    this.action = action;
    this.w = 200;
    this.h = 50;
    this.defaultColor = color(200);
    this.hoverColor = color(150);
    this.currentColor = this.defaultColor;
  }
  
  display(){
    if(this.isHovered()){
      this.currentColor = this.hoverColor;
    }
    else{
      this.currentColor = this.defaultColor;
    }
    
    fill(this.currentColor);
    stroke(0);
    rect(this.x, this.y, this.w, this.h, 10);//圆角矩形
    
    fill(0);
    textSize(24);
    text(this.label, this.x + this.w / 2, this.y + this.h / 2);
  }
  
  isHovered(){
    return mouseX > this.x && mouseX < this.x + this.w && mouseY > this.y && mouseY < this.y + this.h;
  }
  
  checkClick(){
    if(this.isHovered()){
      this.action();
    }
  }
}

class Enemy{
  constructor(x, y, w, h, speed, minX, maxX, scene){
    this.x = x;
    this.y = y + 12;
    this.w = w;
    this.h = h;
    this.baseSpeed = speed;
    this.minX = minX;
    this.maxX = maxX;
    this.direction = 1;
    this.scene = scene;
  }
  
  update(){
    if(!isInCurrentScene(this.scene)){
      return;
    }
    
    if (difficulty === "easy") {
      this.speed = this.baseSpeed * 0.5; // 簡單模式速度變慢
    } else {
      this.speed = this.baseSpeed; // 困難模式保持原速
    }
    
    this.x += this.speed * this.direction;
    
    if(this.x >= this.maxX || this.x <= this.minX){
      this.direction *= -1;
    }
    
    if(this.isCollidingWithPlayer()){
      respawnPlayer();
    }
  }
  
  display(){
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    push();
    if(this.direction < 0){
      image(monsterImg1, this.x, this.y, this.w, this.h);
    }
    else{
      translate(this.x + this.w, this.y);
      scale(-1, 1);
      image(monsterImg1, 0, 0, this.w, this.h);
    }
    pop();
  }
  
  isCollidingWithPlayer(){
    return(player.x < this.x + this.w && player.x + player.w > this.x &&
           player.y < this.y + this.h && player.y + player.h > this.y);
  }
}

function setupNextScene(){
  if(inHiddenScene){
    console.log(`Switch to Hidden Scene ${hiddenSceneIndex}`);
  
    // spikes = [...hiddenScenes[hiddenSceneIndex].spikes];
    // enemies = [...hiddenScenes[hiddenSceneIndex].enemies];
    // platforms = [...hiddenScenes[hiddenSceneIndex].platforms];
    // coins = [...hiddenScenes[hiddenSceneIndex].coins];
    // portals = [...hiddenScenes[hiddenSceneIndex].portals];
    
    for (let cs of hiddenScenes[hiddenSceneIndex].chasingSpikes) {
      cs.sceneIndex = hiddenSceneIndex; 
    }
    
    console.log("Hidden Scene Platforms:", hiddenScenes[hiddenSceneIndex].platforms.map(p => p.x));
  }
  else{
    console.log(`Switch to Scene ${sceneIndex}`);
  
//     spikes = [...scenes[sceneIndex].spikes];
//     enemies = [...scenes[sceneIndex].enemies];
//     platforms = [...scenes[sceneIndex].platforms];
//     coins = [...scenes[sceneIndex].coins];
//     portals = [...scenes[sceneIndex].portals];
    
    console.log("Main Scene Platforms:", scenes[sceneIndex].platforms.map(p => p.x));
  }
  
}

class Scene{
  constructor(){
    this.platforms = [];
    this.coins = [];
    this.spikes = [];
    this.enemies = [];
    this.portals = [];
    this.turrets = [];
    this.bullets = [];
    this.cliffs = [];
    this.breakableBlocks = [];
    this.pipes = [];
    this.movablePlatforms = [];
    this.gates = [];
    this.switches = [];
    this.chasingSpikes = [];
  }
  
  addPlatform(x, y, size, hasCoin = true){
    let exists = this.platforms.some(p => p.x === x && p.y === y);
  if (exists) {
    console.warn(`⚠️ Duplicate Platform at (${x}, ${y}) in hidden scene!`);
  }
    this.platforms.push(new Platform(x, y, size, hasCoin, this));
    
  }
  
  addCoin(x, y, hasGravity = true){
    this.coins.push(new Coin(x, y, hasGravity, this));
  }
  
  addSpike(x, y, w){
    this.spikes.push(new Spike(x, y, w, this));
  }
  
  addEnemy(x, y, w, h, speed, minX, maxX){
    this.enemies.push(new Enemy(x, y, w, h, speed, minX, maxX, this));
  }
  
  addPortal(x, y, sceneType, sceneIndex){
    let portal = new Portal(x, y, sceneType, sceneIndex, this);
    this.portals.push(portal);
    return portal;
  }
  
  addTurret(x, y){
    this.turrets.push(new Turret(x, y, this));
  }
  
  addBullet(x, y, speed){
    this.bullets.push(new Bullet(x, y, speed, this));
  }
  
  addCliff(startX, endX){
    this.cliffs.push({ startX, endX });
  }
  
  addBreakableBlock(x, y, size){
    let block = new BreakableBlock(x, y, size,blockImage2, this);
    this.breakableBlocks.push(block);
  }
  
  addPipe(x, y, w, h){
    this.pipes.push(new Pipe(x, y, w, h, this));
  }
  
  addMovablePlatform(startX, startY, endX, endY, size, speed){
    this.movablePlatforms.push(new MovablePlatform(startX, startY, endX, endY, size, speed, this));
  }
  
  addGate(x){
    this.gates.push(new Gate(x, this));
  }
  
  addSwitch(x, y){
    this.switches.push(new Switch(x, y, this));
  }
  
  addChasingSpike(){
    this.chasingSpikes.push(new ChasingSpike(this));
  }
  
  update(){
    for(let platform of this.platforms) platform.update();
    for(let coin of this.coins) coin.update();
    for(let spike of this.spikes) spike.update();
    for(let enemy of this.enemies) enemy.update();
    for(let portal of this.portals) portal.update();
    for(let turret of this.turrets) turret.update();
    for(let bullet of this.bullets) bullet.update();
    for(let block of this.breakableBlocks) block.update();
    for(let pipe of this.pipes) pipe.update();
    for (let movablePlatform of this.movablePlatforms) movablePlatform.update();
    for (let gate of this.gates) gate.update();
    for (let s of this.switches) s.update();
      
    // for (let cs of this.chasingSpikes) cs.update();
    }
  
  display(){
    for(let platform of this.platforms) platform.display();
    for(let coin of this.coins) coin.display();
    for(let spike of this.spikes) spike.display();
    for(let enemy of this.enemies) enemy.display();
    for(let portal of this.portals) portal.display();
    for(let turret of this.turrets) turret.display();
    for(let bullet of this.bullets) bullet.display();
    for(let block of this.breakableBlocks) block.display();
    for(let pipe of this.pipes) pipe.display();
    for (let movablePlatform of this.movablePlatforms) movablePlatform.display();
    for (let gate of this.gates) gate.display();
    for (let s of this.switches) s.display();
    // for (let cs of this.chasingSpikes) cs.display();
  }
}

class Turret{
  constructor(x, y, scene){
    this.x = x;
    this.y = y;
    this.scene = scene;
    this.fireRate = 60;
    this.timer = 0;
    this.w = 30;
    this.h = 30;
  }
  
  update(){
    if(!isInCurrentScene(this.scene)){
      return;
    }
    this.timer++;
    if(this.timer >= this.fireRate){
      this.scene.bullets.push(new Bullet(this.x + 10, this.y, -2, this.scene));
      this.timer = 0;
    }
    
    if(this.isCollidingWithPlayer()){
      respawnPlayer();
    }
  }
  
  display(){
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    image(turretImg, this.x, this.y, this.w, this.h);
  }
  
  isCollidingWithPlayer(){
    return(player.x < this.x + 20 && player.x + player.w > this.x &&
           player.y < this.y + 20 && player.y + player.h > this.y);
  }
}

class Bullet{
  constructor(x, y, speed, scene){
    this.x = x;
    this.y = y;
    this.scene = scene;
    this.baseSpeed = speed;
    this.size = 10;
  }
  
  update(){
    if (difficulty === "easy") {
      this.speed = this.baseSpeed * 2; // 簡單模式速度減半
    } else {
      this.speed = this.baseSpeed; // 困難模式維持原速度
    }
    
    this.y += this.speed;
    if(this.y < 0){
      let index = this.scene.bullets.indexOf(this);
      if (index > -1) {
        this.scene.bullets.splice(index, 1);
      }
    }

    if(!isInCurrentScene(this.scene)){
      return;
    }
    
    if(this.isCollidingWithPlayer()){
      respawnPlayer();
    }
  }
  
  display(){
    image(bulletImg, this.x, this.y, this.size, this.size);
  }
  
  isCollidingWithPlayer(){
    return(player.x < this.x + this.size && player.x + player.w > this.x &&
           player.y < this.y + this.size && player.y + player.h > this.y);
  }
}

class BreakableBlock{
  constructor(x, y, size, image, scene){
    this.x = x;
    this.y = y + 14 ;
    this.size = size;
    this.image = image;
    this.exists = true;
    this.scene = scene;
  }
  
  update(){
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    if(!this.exists) return;
    
    if (player.x + player.w > this.x && player.x < this.x + this.size &&
        player.y < this.y + this.size && player.prevY >= this.y + this.size &&
        player.velocityY < 0) {
      player.y = this.y + this.size;
      this.exists = false;
      player.velocityY = 0;
      return;
    }
    
    if (player.y + player.h > this.y && player.y < this.y + this.size) {
      // **人物从右侧撞到方块**
      let nextX = player.x + player.velocityX; // 预测下一帧 X 位置
      if (player.velocityX > 0 && player.prevX + player.w <= this.x && nextX + player.w > this.x) {
        player.x = this.x - player.w;
        player.velocityX = 0;
      }
      // **人物从左侧撞到方块**
      if (player.velocityX < 0 && player.prevX >= this.x + this.size && nextX < this.x + this.size) {
        player.x = this.x + this.size;
        player.velocityX = 0;
      }
    }
  }
  
  display(){
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    if(!this.exists) return;
    
    if(this.image){
      image(this.image, this.x,this.y,this.size, this.size);
    }else{
    
    fill(150, 75, 0);
    rect(this.x, this.y, this.size, this.size);
    }
  }
}

function checkFallDeath(){
  let currentScene = inHiddenScene ? hiddenScenes[hiddenSceneIndex] : scenes[sceneIndex];
  let isOverCliff = false;
  for(let cliff of currentScene.cliffs){
    if(player.x > cliff.startX && player.x + player.w < cliff.endX){
      isOverCliff = true;
      break;
    }
  }
  
  if(isOverCliff && player.onGround){
    player.onGround =  false;
    player.velocityY = 0;
  }
  
  if(player.y > height - groundHeight + player.h){
    respawnPlayer();
  }
}

function isPlayerOverCliff(){
  let currentScene = inHiddenScene ? hiddenScenes[hiddenSceneIndex] : scenes[sceneIndex];
  
  for(let cliff of currentScene.cliffs){
    if(player.x > cliff.startX && player.x + player.w < cliff.endX + player.speed){
      return true;
    }
  }
  return false;
}

class Pipe{
  constructor(x, y, w, h, scene){
    this.x = x;
    this.y = y + 14;
    this.w = w;
    this.h = h;
    this.scene = scene;
  }
  
  update(){
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    if(player.x + player.w > this.x && player.x < this.x + this.w &&
       player.y + player.h >= this.y && player.y + player.h - player.velocityY < this.y + 5 &&
       player.velocityY > 0){
      player.y = this.y - player.h;
      player.velocityY = 0;
      player.onGround = true;
    }
    
    if(player.y + player.h > this.y && player.y < this.y + this.h){
      if (player.x + player.w > this.x && player.x < this.x + this.w / 2) {
        player.x = this.x - player.w; // 左侧
      } else if (player.x < this.x + this.w && player.x + player.w > this.x + this.w / 2) {
        player.x = this.x + this.w; // 右侧
      }
    }
    
    if(player.y + player.h === this.y && keyIsDown(controls.use.charCodeAt(0))){
      enterHiddenLevel();
    }
  }
  
  display(){
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    image(pipeImg, this.x, this.y, this.w, this.h);
  }
}

function enterHiddenLevel(){
  inHiddenScene = true;
  hiddenSceneIndex = 0;
  player.x = 50;
  player.y = height - groundHeight - player.h;
  
  setupNextScene();
}

class MovablePlatform{
  constructor(startX, startY, endX, endY, size, speed = 5, scene){
    this.x = startX;
    this.y = startY;
    this.startX = startX;
    this.startY = startY;
    this.endX = endX;
    this.endY = endY;
    this.size = size;
    this.w = size;
    this.speed = speed;
    this.moving = false;
    this.reachedDestination = false;
    this.reset();
    this.scene = scene;
  }
  
  update(){
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    if(!this.moving && dist(player.x + player.w / 2, player.y + player.h / 2, this.startX + this.size / 2, this.startY + this.size / 2) < 70){
      this.moving = true;
    }
    
    if (player.y + player.h > this.y && player.y < this.y + this.size) {
      // **人物从右侧撞到方块**
      let nextX = player.x + player.velocityX; // 预测下一帧 X 位置
      if (player.velocityX > 0 && player.prevX + player.w <= this.x && nextX + player.w > this.x) {
        player.x = this.x - player.w;
        player.velocityX = 0;
      }
      // **人物从左侧撞到方块**
      if (player.velocityX < 0 && player.prevX >= this.x + this.size && nextX < this.x + this.size) {
        player.x = this.x + this.size;
        player.velocityX = 0;
      }
    }
    
    if (player.x + player.w > this.x && player.x < this.x + this.size &&
        player.y < this.y + this.size && player.prevY >= this.y + this.size &&
        player.velocityY < 0) {
      player.y = this.y + this.size;
      player.velocityY = 0;
      
      return; 
    }
    
    if (player.x + player.w > this.x && player.x < this.x + this.size &&
        player.y + player.h > this.y && player.prevY + player.h <= this.y &&
        player.velocityY > 0) {
      player.y = this.y - player.h;
      player.velocityY = 0;
      player.onGround = true;
      return;
    }
    
    if(this.moving && !this.reachedDestination){
      let dx = this.endX - this.x;
      let dy = this.endY - this.y;
      let distance = sqrt(dx * dx + dy * dy);
      
      if(distance > this.speed){
        this.x += (dx / distance) * this.speed;
        this.y += (dy / distance) * this.speed;
      }
      else{
        this.x = this.endX;
        this.y = this.endY;
        this.reachedDestination = true;
      }
    }
  }
  
  display(){
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    image(blockImage, this.x, this.y, this.size, this.size);
  }
  
  reset() {
    console.log("Resetting platform to", this.startX, this.startY);
    this.x = this.startX;
    this.y = this.startY;
    this.moving = false;
    this.reachedDestination = false;
  }
}

class Gate{
  constructor(x, scene) {
    this.x = x;
    this.y = 0;
    this.w = 30;
    this.h = height - groundHeight;
    this.open = false;
    this.scene = scene;
  }
  
  update() {
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    if (this.open) return;

    if (
      player.x + player.w > this.x &&
      player.x < this.x + this.w &&
      player.y + player.h > this.y &&
      player.y < this.y + this.h
    ) {
      player.x = this.x - player.w;
      player.velocityX = 0;
    }
  }

  display() {
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    fill(this.open ? "gray" : "brown");
    rect(this.x, this.y, this.w, this.h);
  }
  
  reset() {
    this.open = false; 
  }
}

class Switch {
  constructor(x, y, scene) {
    this.x = x;
    this.y = y;
    this.w = 20;
    this.h = 20;
    this.activated = false;
    this.nearPlayer = false;
    this.scene = scene;
  }

  update() {
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    this.nearPlayer = (
      player.x + player.w > this.x &&
      player.x < this.x + this.w &&
      player.y + player.h > this.y &&
      player.y < this.y + this.h
    );
  }

  display() {
    if (!isInCurrentScene(this.scene)){
      return;
    } 
    fill(this.activated ? "green" : "red");
    rect(this.x, this.y, this.w, this.h);
    if (this.nearPlayer && !this.activated) {
      fill("white");
      textSize(16);
      text("Press E Open Challenge", this.x + 30, this.y - 10);
    }
  }
  
  reset() {
    this.activated = false; // 复原时关闭开关
  }
  
  activate() {
    if (this.nearPlayer && !this.activated) {
      this.activated = true;
      console.log("Switch activated! Gate opening...");

      // **打开所有门**
      for (let g of hiddenScenes[hiddenSceneIndex].gates) {
        g.open = true;
      }

      // **让所有追击刺开始追击**
      for (let cs of hiddenScenes[hiddenSceneIndex].chasingSpikes) {
        cs.start();  // 调用 `start()` 让追击刺从头开始
      }
    }
  }
}

class ChasingSpike {
  constructor(scene) {
    this.x = -30;
    this.y = 0;
    this.w = 30;
    this.h = height - groundHeight;
    this.speed = 2;
    this.active = false;
    this.sceneIndex = 0;
    this.startFrame = frameCount; 
    this.scene = scene;
  }

  update() {
    if (!this.active) return;
    // **追击刺应当跨幕持续运动**
    let elapsedFrames = frameCount - this.startFrame;
    this.x = elapsedFrames * this.speed - this.w;

    // **检测幕切换**
    this.sceneIndex = Math.floor(this.x / width);

    // **检测玩家碰撞**
    if (this.sceneIndex === hiddenSceneIndex) {
      let relativeX = this.x - this.sceneIndex * width; // 转换为当前幕坐标
      if (
        player.x < relativeX + this.w &&
        player.x + player.w > relativeX &&
        player.y < this.y + this.h &&
        player.y + player.h > this.y
      ) {
        respawnPlayer();
      }
    }
  }

  display() {
    if (!this.active) return;
    if (this.sceneIndex !== hiddenSceneIndex) return;
    fill("black");
    rect(this.x - this.sceneIndex * width, this.y, this.w, this.h);
  }
  
  reset() {
    this.x = -30;
    this.sceneIndex = 0;
    this.active = false;
    this.startFrame = frameCount; 
  }
  
  start() {
    if (!this.active) {
      this.active = true;
      this.startFrame = frameCount; // 重新计算帧数
    }
  }
}

class upgradeButton extends Button {
  constructor(x, y, label, action) {
    super(x, y, label, action);
    this.w = 300; // 变大宽度
    this.h = 450; // 变大高度
  }
}

function isInCurrentScene(scene){
  return scene === (inHiddenScene ? hiddenScenes[hiddenSceneIndex] : scenes[sceneIndex]);
}

function drawUpgrade() {
  upgradeButtons.push(new upgradeButton(50, 75, "Increase Size", () => {
    player.h = 60;
    player.w = 37.5;
    player.jumpPower = -Math.sqrt(2 * player.gravity * (150 + (player.h - 40) * 2)); 
    gameState = "playing";
  }));
  upgradeButtons.push(new upgradeButton(450, 75, "Double Jump", () => {
    player.canDoubleJump = true;
    gameState = "playing";
  }));

  fill(0);
  textSize(30);
  text("Select an upgrade option", 400, 50);
  
  for (let btn of upgradeButtons) {
    btn.display();
  }
}

function preload(){
  bgImage = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/BACKGROUND.JPG");
  blockImage = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/BRICK1.PNG");
  blockImage2 = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/BRICK2.PNG");
  groundImage = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/FLOOR.PNG");
  spikeImage = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/SPIKE.PNG");
  portalImgClosed = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/DOOR2.PNG");
  portalImgOpened = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/DOOR1.PNG");
  playerImg1 = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/MaleCat1.PNG");
  playerImg2 = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/MaleCat2.PNG");
  pipeImg = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/HollowTree.PNG");
  monsterImg1 = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/Monster1.png");
  bulletImg = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/Bullet.PNG");
  turretImg = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/Turret.PNG");
  coinImg = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/Can.png");
  coverImg = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/cover.PNG");
  logo2Img = loadImage("https://raw.githubusercontent.com/Yuki-457/noname/main/images/logo2.PNG");
}
