let buttons = [];
let gameState = "menu";
let volume = 5;
let controls = {left:'A', right:'D', attack:'J', jump:'K', item:'I', pause:'P', use:'E'};
let controlKeys = Object.keys(controls);
let changingKey = null;
let titleFontSize = 48;
let titleY;
let groundHeight = 150;
let sceneIndex = 0;
let goldCoins = 0;
let level = 1;
let exp = 0;
let elapsedTime = 0;
let portals = [];
let unlockedPortals = [];
let isChoosingPortal = false;
let selectedPortalIndex = 0;
let spikes = [];
let currentSpawnPoint = null;
let platforms = [];
let coins = [];
let enemies = [];
let scenes = [];
let maxScenes = 3;

function setup() {
  createCanvas(800, 600);
  textAlign(CENTER, CENTER);
  titleY = height / 4;//设置标题位置
  sceneIndex = 0;
  
  let startY = height / 2;
  
  buttons.push(new Button(width / 2 - 100, height / 2 - 60, "New Start", () => gameState = "playing"));
  buttons.push(new Button(width / 2 - 100, height / 2, "Continue", () => console.log("Load Game")));
  buttons.push(new Button(width / 2 - 100, height / 2 + 60, "Setting", () => gameState = "settings"));
  buttons.push(new Button(width / 2 - 100, height / 2 + 120, "Exit", () => noLoop()));
  //按钮位置
  
  player = new Player(50, height - groundHeight - 40);
  //portals.push(new Portal(100, height - groundHeight - 60));
  //currentSpawnPoint = {x: 100, y: height - groundHeight - 50};
  //spikes.push(new Spike(250, height - groundHeight, 50));
  
  for(let i = 0; i < maxScenes; i++){
    scenes.push(new Scene());
  }
  
  scenes[0].addPlatform(450, height - groundHeight - 130, 30);
  scenes[0].addPlatform(480, height - groundHeight - 130, 30);
  scenes[0].addPlatform(510, height - groundHeight - 130, 30);
  scenes[0].addPlatform(540, height - groundHeight - 130, 30);
  scenes[0].addEnemy(400, height - groundHeight - 25, 25, 25, 2, 400, 700);
  scenes[0].addSpike(250, height - groundHeight, 50);
  //scenes[0].addCoin(460, height - groundHeight - 160);
  
  let portal1 = scenes[0].addPortal(100, height - groundHeight - 60);
  lastCheckPoint = { x: portal1.x, y: portal1.y, scene: 0 };
  
}

function draw() {
  background(240);
  
  if(gameState === "menu"){
    drawMenu();
  }
  else if(gameState === "settings"){
    drawSettings();
  }
  else if(gameState === "playing"){
    drawGame();
  }
}

function drawMenu(){
  background(240);
  fill(50);
  textSize(titleFontSize);
  text("Mario Soul", width / 2, titleY);
  
  for (let btn of buttons) {
    btn.display();
  }
}

function drawGame(){
  background(135, 206, 250);
  fill(100, 200, 100);
  rect(0, height - groundHeight, width, groundHeight);
  
  //for(let portal of portals){
    //portal.update();
   // portal.display();
  //}
  
  
  
  /*for(let spike of spikes){
    spike.update();
    spike.display();
  }
  
  
  for(let platform of platforms){
    platform.update();
    platform.display();
  }
  
  for(let coin of coins){
    coin.update();
    coin.display();
  }
  
  for(let enemy of enemies){
    enemy.update();
    enemy.display();
  }
  
  */
  
  scenes[sceneIndex].update();
  scenes[sceneIndex].display();
  player.update();
  player.display();
  drawHUD();
  
  //fill(0);
  //textSize(20);
  //text(`Scene: ${sceneIndex}`, width - 80, 30);
  
  if(isChoosingPortal){
    drawPortalSelection();
  }
}

class Platform{
  constructor(x, y, size){
    this.x = x;
    this.y = y;
    this.size = size;
    this.hasCoin = true;
  }
  
  update(){
    if(player.x + player.w > this.x && player.x < this.x + this.size &&
       //player.y == this.y + this.size && player.velocityY < 0){
       //player.y - player.velocityY < this.y + this.size && player.y + player.velocityY < this.y + this.size){
       player.y <= this.y + this.size && player.y >= this.y && player.velocityY < 0){
      player.velocityY = 0;
      if(this.hasCoin){
        let newCoin = new Coin(this.x + this.size / 2, this.y - 10);
        scenes[sceneIndex].coins.push(new Coin(this.x + this.size / 2, this.y - 10));
        this.hasCoin = false;
      }
    }
    
    if(player.x + player.w > this.x && player.x < this.x + this.size &&
       player.y + player.h >= this.y && player.y + player.h - player.velocityY < this.y + 5 &&
       player.velocityY > 0){
      player.y = this.y - player.h;
      player.velocityY = 0;
      player.onGround = true;
    }
    
//    if(player.x + player.w > this.x && player.x < this.x + this.size &&
 //      player.y + player.h > this.y && player.velocityY > 0){
   //   player.y = this.y - player.h;
     // player.velocityY = 0;
     // player.onGround = true;
    //}
    
    
  }
  
  display(){
    fill(150, 75, 0);
    rect(this.x, this.y, this.size, this.size);
  }
}

class Coin{
  constructor(x, y){
    this.x = x;
    this.y = y;
    this.size = 15;
    this.collected = false;
    this.velocityY = -2;
    this.gravity = 0.5;
  }
  
  update(){
    this.velocityY += this.gravity;
    this.y += this.velocityY;
    
    if(player.x + player.w > this.x && player.x < this.x + this.size &&
       player.y + player.h > this.y && player.y < this.y + this.size &&
       !this.collected){
      this.collected = true;
      goldCoins += 1;
      exp += 1;
      
      let index = coins.indexOf(this);
      if(index > -1){
        coins.splice(index, 1);
      }
    }
  }
  
  display(){
    if(!this.collected){
      fill("gold");
      ellipse(this.x, this.y, this.size);
    }
  }
}

class Spike{
  constructor(x, y, w){
    this.x = x;
    this.y = height - groundHeight;
    this.w = w;
    this.h = 15;
    this.visible = false;
  }
  
  update(){
    if(dist(player.x + 20, player.y + 30, this.x + this.w / 2, this.y) < 70){
      this.visible = true;
    }
    
    if(this.visible && this.isCollidingWithPlayer()){
      respawnPlayer();
      this.visible = false;
      
    }
  }
  
  display(){
    if(this.visible){
      fill(200, 0, 0);
      triangle(this.x, this.y, this.x + this.w / 2, this.y - this.h, this.x + this.w, this.y);
    }
  }
  
  isCollidingWithPlayer(){
    return(player.x < this.x + this.w && player.x + player.w > this.x && 
           player.y + player.h > this.y - this.h);
  }
}

function respawnPlayer(){
  if(lastCheckPoint){
    sceneIndex = lastCheckPoint.scene;
    player.x = lastCheckPoint.x;
    player.y = lastCheckPoint.y;
    
  }
  else{
    sceneIndex = 0;
    player.x = 50;
    player.y = height - groundHeight - 40;
  }
    
  exp = 0;
  
  let scene = scenes[sceneIndex];
  scene.coins = [];
  
  for(let spike of scene.spikes){
    spike.visible = false;
  }
  for(let platform of platforms){
    platform.hasCoin = true;
    //scene.coins.push(new Coin(platform.x + platform.size / 2, platform.y - 10));
  }
  
  
  //scene.enemies = [];
  //scene.spikes = [];
  setupNextScene();
}

function drawPortalSelection(){
  fill(0, 150);
  rect(200, 150, 400, 300, 20);
  fill(250);
  textSize(24);
  text("Select a Portal", 400, 180);
  
  for(let i = 0; i < unlockedPortalIndex; i++){
    let portal = unlockedPortals[i];
    fill(i === selectedPortalIndex ? "yellow" : "white");
    text(`Portal ${i + 1} (X: ${portal.x})`, 400, 220 + i * 40);
  }
  
  textSize(16);
  fill(200);
  text("↑/↓ to navigate, E to confirm, ESC to cancel", 400, 420);
}

function drawHUD(){
  fill(255);
  textSize(16);
  
  text(`Level ${level}`, 80, 30);
  fill("gold");
  rect(20, 40, (exp / 10) * 100, 10);
  noFill();
  stroke(255);
  rect(20, 40, 100, 10);
  
  let timeElapsed = Math.floor(millis() / 1000);
  text(`Time: ${timeElapsed}s`, width - 80, 30);
}

class Portal{
  constructor(x, y){
    this.x = x;
    this.y = y;
    this.w = 60;
    this.h = 60;
    this.unlocked = false;
  }
  
  update(){
    if(!this.unlocked && this.isCollidingWithPlayer()){
      this.unlocked = true;
      unlockedPortals.push(this);
      goldCoins += 5;
      exp += 5;
      lastCheckPoint = { x: this.x, y: this.y, scene: sceneIndex };
    }
    
    if(this.unlocked && this.isCollidingWithPlayer() && keyIsDown(controls.use.charCodeAt(0))){
      if(lastCheckPoint){
        teleport(lastCheckPoint);
      }
    }
  }
  
  display(){
    fill(this.unlocked ? "blue" : "gray");
    rect(this.x, this.y, this.w, this.h);
  }
  
  isCollidingWithPlayer(){
    return(player.x < this.x + this.w && player.x + player.w > this.x &&
           player.y < this.y + this.h && player.y + player.h > this.y);
  }
}

function teleport(targetPortal){
  if(targetPortal){
    player.x = targetPortal.x;
    player.y = targetPortal.y;
  }
}

function collection(){
  goldCoins += 1;
  exp += 1;
  if(exp >= 10){
    exp = 0;
    level += 1;
  }
}

class Player{
  constructor(x, y){
    this.x = x;
    this.y = y;
    this.w = 25;
    this.h = 40;
    this.speed = 3;
    this.gravity = 0.5;
    this.jumpPower = -Math.sqrt(2 * this.gravity * 150);
    this.velocityY = 0;
    this.onGround = false;
    this.canDoubleJump = false;
    this.hasDoubleJumped = false;
  }
  
  update(){
    if(keyIsDown(controls.left.charCodeAt(0))){
      this.x -= this.speed;
    }
    if(keyIsDown(controls.right.charCodeAt(0))){
      this.x += this.speed;
    }
    
    if(keyIsDown(controls.jump.charCodeAt(0))){
      if(this.onGround){
        this.velocityY = this.jumpPower;
        this.onGround = false;
        this.hasDoubleJumpes = false;
      }
      else if(this.canDoubleJump && !this.hasDoubleJumped){
        this.velocityY = this.jumpPower * 0.9;
        this.hasDoubleJumped = true;
      }
    }
    
    this.velocityY += this.gravity;
    this.y += this.velocityY;
    
    if(this.y >= height - groundHeight - this.h){
      this.y = height - groundHeight - this.h;
      this.velocityY = 0;
      this.onGround = true;
      this.hasDoubleJumped = false;
    }
    
    this.checkSceneTransition();
    
    this.x = constrain(this.x, 0 - this.w / 2, width - this.w / 2);
  }
  
  checkSceneTransition(){
    let centerX = this.x + this.w / 2;
    
    if(centerX >= width && sceneIndex < maxScenes - 1){
      sceneIndex++;
      this.x = this.w / 2;
      setupNextScene();
    }
    
    if(centerX <= 0 && sceneIndex > 0){
      sceneIndex--;
      this.x = width - this.w / 2;
      setupNextScene();
    }
  }
  
  display(){
    fill(255, 0, 0);
    rect(this.x, this.y, this.w, this.h);
  }
}

function drawSettings(){
  fill(50);
  textSize(32);
  text("Settings", width / 2, 50);
  
  textSize(24);
  text("Volume", width / 2, 150);
  text(volume, width / 2, 180);
  rect(width / 2 - 70, 170, 30, 30);
  rect(width / 2 + 40, 170, 30, 30);
  text("-", width / 2 - 55, 185);
  text("+", width / 2 + 55, 185);
  
  let controlLabels = ["Left", "Right", "Attack", "Jump", "Item", "Pause", "Use"];
  let keys = Object.values(controls);
  
  for(let i = 0; i < controlLabels.length; i++){
    let y = 250 + i * 40;
    
    let displayText = changingKey === controlKeys[i] ? "Press any key..." : `${controlLabels[i]}: ${keys[i]}`;
    
    if(changingKey === controlKeys[i]){
      fill(255, 0, 0);
    }
    else{
      fill(0);
    }
    text(displayText, width / 2, y);
    
    stroke(0);
    noFill();
    rect(width / 2 - 100, y - 15, 200, 30);
  }
  
  textSize(20);
  text("Press any key to change setting", width / 2, 520);
  text("Press ESC to return", width / 2, 550);
}

function mousePressed(){
  if(gameState === "menu"){
    for(let btn of buttons){
      btn.checkClick();
    }
  }
  else if(gameState === "settings"){
    if(mouseX > width / 2 - 70 && mouseX < width / 2 - 40 && mouseY > 170 && mouseY < 200){
      volume = max(0, volume - 1);
    }
    if(mouseX > width / 2 + 40 && mouseX < width / 2 + 70 && mouseY > 170 && mouseY < 200){
      volume = min(10, volume + 1);
    }
    
    let controlLabels = ["Left", "Right", "Attack", "Jump", "Item", "Pause", "Use"];
    for(let i = 0; i < controlLabels.length; i++){
      let y = 250 + i * 40;
      if(mouseX > width / 2 - 100 && mouseX < width / 2 + 100 && mouseY > y - 15 && mouseY < y + 15){
        changingKey = controlKeys[i];
      }
    }
  }
}

function keyPressed(){
  if(gameState === "settings"){
    if(keyCode === ESCAPE){
      changingKey = null;
      gameState = "menu";
    }
    else if(changingKey){
      controls[changingKey] = key.toUpperCase();
      changingKey = null;
    }
  }
  
  else if(isChoosingPortal){
    if(keyCode === UP_ARROW){
      selectedPortalIndex = max(0, selectedPortalIndex - 1);
    }
    else if(keyCode === DOWN_ARROW){
      selectedPortalIndex = min(0, selectedPortalIndex - 1);
    }
    else if(keyCode === controls.use.charCodeAt(0)){
      teleport(unlockedPortals[selectedPortalIndex]);
      isChoosingPortal = false;
    }
    else if(keyCode === ESCAPE){
      isChoosingPortal = false;
    }
  }
}

class Button{
  constructor(x, y, label, action){
    this.x = x;
    this.y = y;
    this.label = label;
    this.action = action;
    this.w = 200;
    this.h = 50;
    this.defaultColor = color(200);
    this.hoverColor = color(150);
    this.currentColor = this.defaultColor;
  }
  
  display(){
    if(this.isHovered()){
      this.currentColor = this.hoverColor;
    }
    else{
      this.currentColor = this.defaultColor;
    }
    
    fill(this.currentColor);
    stroke(0);
    rect(this.x, this.y, this.w, this.h, 10);//圆角矩形
    
    fill(0);
    textSize(24);
    text(this.label, this.x + this.w / 2, this.y + this.h / 2);
  }
  
  isHovered(){
    return mouseX > this.x && mouseX < this.x + this.w && mouseY > this.y && mouseY < this.y + this.h;
  }
  
  checkClick(){
    if(this.isHovered()){
      this.action();
    }
  }
}

class Enemy{
  constructor(x, y, w, h, speed, minX, maxX){
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.speed = speed;
    this.minX = minX;
    this.maxX = maxX;
    this.direction = 1;
  }
  
  update(){
    this.x += this.speed * this.direction;
    
    if(this.x >= this.maxX || this.x <= this.minX){
      this.direction *= -1;
    }
    
    if(this.isCollidingWithPlayer()){
      respawnPlayer();
    }
  }
  
  display(){
    fill(0, 200, 0);
    rect(this.x, this.y, this.w, this.h);
  }
  
  isCollidingWithPlayer(){
    return(player.x < this.x + this.w && player.x + player.w > this.x &&
           player.y < this.y + this.h && player.y + player.h > this.y);
  }
}

function setupNextScene(){
  console.log(`Switch to Scene ${sceneIndex}`);
  
  spikes = scenes[sceneIndex].spikes;
  enemies = scenes[sceneIndex].enemies;
  platforms = scenes[sceneIndex].platforms;
  coins = scenes[sceneIndex].coins;
  portals = scenes[sceneIndex].portals;
  
}

class Scene{
  constructor(){
    this.platforms = [];
    this.coins = [];
    this.spikes = [];
    this.enemies = [];
    this.portals = [];
  }
  
  addPlatform(x, y, size){
    this.platforms.push(new Platform(x, y, size));
  }
  
  addCoin(x, y){
    this.coins.push(new Coin(x, y));
  }
  
  addSpike(x, y, w){
    this.spikes.push(new Spike(x, y, w));
  }
  
  addEnemy(x, y, w, h, speed, minX, maxX){
    this.enemies.push(new Enemy(x, y, w, h, speed, minX, maxX));
  }
  
  addPortal(x, y){
    let portal = new Portal(x, y);
    this.portals.push(portal);
    return portal;
  }
  
  update(){
    for(let platform of this.platforms) platform.update();
    for(let coin of this.coins) coin.update();
    for(let spike of this.spikes) spike.update();
    for(let enemy of this.enemies) enemy.update();
    for(let portal of this.portals) portal.update();
  }
  
  display(){
    for(let platform of this.platforms) platform.display();
    for(let coin of this.coins) coin.display();
    for(let spike of this.spikes) spike.display();
    for(let enemy of this.enemies) enemy.display();
    for(let portal of this.portals) portal.display();
  }
}
